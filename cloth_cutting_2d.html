<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloth Sim: Texture & Wind</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; cursor: crosshair; }
        
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.85); 
            color: #eee; padding: 15px; border-radius: 8px;
            border: 1px solid #444; pointer-events: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            width: 220px;
        }

        #controls {
            position: absolute; top: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px;
            align-items: flex-end;
        }

        button {
            padding: 8px 16px; border: none; border-radius: 4px;
            background: #333; color: white; cursor: pointer;
            font-size: 13px; font-weight: 600;
            border: 1px solid #555; transition: 0.2s;
            width: 100px;
        }
        button:hover { background: #555; }
        button.active { background: #4fd1c5; color: #111; border-color: #4fd1c5; }
        
        .btn-group { display: flex; gap: 5px; }
        .label { font-size: 11px; color: #aaa; text-transform: uppercase; margin-bottom: 4px; }

        h2 { margin: 0 0 5px 0; font-size: 16px; color: #fff; }
        p { margin: 0; font-size: 12px; opacity: 0.7; }
    </style>
</head>
<body>

<div id="ui">
    <h2>Cloth Engine v3</h2>
    <p>Left Click: Tool â€¢ Right Click: Drag</p>
    <p style="margin-top:10px; color:#f6ad55;" id="tool-display">Tool: Knife</p>
</div>

<div id="controls">
    <div style="text-align:right">
        <div class="label">View Mode</div>
        <div class="btn-group">
            <button onclick="setView('textured')" id="view-textured" class="active">Texture</button>
            <button onclick="setView('wireframe')" id="view-wireframe">Wireframe</button>
        </div>
    </div>

    <div style="text-align:right">
        <div class="label">Material</div>
        <div class="btn-group">
            <button onclick="setMaterial('cotton')" id="btn-cotton" class="active">Cotton</button>
            <button onclick="setMaterial('nylon')" id="btn-nylon">Nylon</button>
            <button onclick="setMaterial('denim')" id="btn-denim">Denim</button>
        </div>
    </div>

    <div style="text-align:right">
        <div class="label">Tool</div>
        <div class="btn-group">
            <button onclick="setTool('knife')" id="tool-knife" class="active">Knife</button>
            <button onclick="setTool('lighter')" id="tool-lighter" style="color:#f6ad55;">Lighter</button>
        </div>
    </div>

    <div style="text-align:right; margin-top:5px;">
        <button onclick="toggleWind()" id="btn-wind" style="width:100%">Wind: OFF</button>
    </div>

    <button onclick="createCloth()" style="background:#882222; margin-top:10px; width:100%">Reset</button>
</div>

<canvas id="c"></canvas>

<script>
// -----------------------------------------------------------
// 1. TEXTURE GENERATION (Procedural)
// -----------------------------------------------------------
// We generate a small noise pattern on a hidden canvas to use as a fill pattern.
// This avoids loading external images and CORS issues.
let clothPattern = null;
function generateFabricPattern() {
    const pCanvas = document.createElement('canvas');
    pCanvas.width = 64; pCanvas.height = 64;
    const pCtx = pCanvas.getContext('2d');
    
    // Base Color
    pCtx.fillStyle = '#ffffff'; 
    pCtx.fillRect(0,0,64,64);
    
    // Add Noise/Weave
    pCtx.fillStyle = 'rgba(0,0,0,0.15)';
    for(let i=0; i<400; i++) {
        pCtx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
    }
    // Add "Thread" lines
    pCtx.strokeStyle = 'rgba(0,0,0,0.08)';
    pCtx.beginPath();
    for(let i=0; i<64; i+=4) {
        pCtx.moveTo(i, 0); pCtx.lineTo(i, 64);
        pCtx.moveTo(0, i); pCtx.lineTo(64, i);
    }
    pCtx.stroke();
    
    return ctx.createPattern(pCanvas, 'repeat');
}

// -----------------------------------------------------------
// CONFIGURATION
// -----------------------------------------------------------

const CONFIG = {
    cols: 45, // Slightly reduced for performance in texture mode
    rows: 30,
    spacing: 14,
    tearSensitivity: 5,
};

const MATERIALS = {
    cotton: { friction: 0.96, gravity: 0.25, stiffness: 3, color: '#e0e0e0', burnRate: 1.0, windMod: 1.0 },
    nylon: { friction: 0.99, gravity: 0.25, stiffness: 8, color: '#ff00aa', burnRate: 3.5, windMod: 1.5 }, 
    denim: { friction: 0.90, gravity: 0.45, stiffness: 12, color: '#6080b0', burnRate: 0.5, windMod: 4.5 } 
};

let currentMat = MATERIALS.cotton;
let currentTool = 'knife';
let viewMode = 'textured'; // 'wireframe' or 'textured'
let windEnabled = false;

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let width, height;
const mouse = { x: 0, y: 0, px: 0, py: 0, down: false, button: 0 };
let draggedPoint = null;

// Init Texture
clothPattern = generateFabricPattern();

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// -----------------------------------------------------------
// PHYSICS ENGINE
// -----------------------------------------------------------

class Point {
    constructor(x, y, pinned) {
        this.x = x; this.y = y;
        this.px = x; this.py = y;
        this.pinned = pinned;
    }
    update() {
        if (this.pinned) return;
        if (this === draggedPoint) {
            this.px = this.x; this.py = this.y;
            this.x = mouse.x; this.y = mouse.y;
            return;
        }

        let vx = (this.x - this.px) * currentMat.friction;
        let vy = (this.y - this.py) * currentMat.friction;

        // --- UPDATED WIND MATH ---
        if (windEnabled) {
            const time = Date.now() / 300; // Faster time = faster oscillation
            // Base Wave
            let wave = Math.sin(this.y * 0.02 + time) * 0.8;
            // "Gust" Noise (using x position)
            wave += Math.sin(this.x * 0.03 + time * 2.5) * 0.4;
            // Random Thrashing
            wave += Math.sin(time * 5) * 0.2;

            // Apply force
            vx += wave * 0.8 * currentMat.windMod;
            
            // Add slight lift (Bernoulli-ish effect)
            vy -= Math.abs(wave) * 0.1;
        }

        this.px = this.x; this.py = this.y;
        this.x += vx; this.y += vy; this.y += currentMat.gravity;
    }
    constrain() {
        if (this.pinned || this === draggedPoint) return;
        if (this.y > height - 5) { this.y = height - 5; this.x += (this.px - this.x) * 0.5; }
        if (this.x > width) this.x = width;
        if (this.x < 0) this.x = 0;
    }
}

class Stick {
    constructor(p1, p2, isStructural) {
        this.p1 = p1; this.p2 = p2;
        this.length = Math.hypot(p1.x - p2.x, p1.y - p2.y);
        this.active = true;
        this.isStructural = isStructural;
        this.health = 100;
    }
    update() {
        if (!this.active) return;
        const dx = this.p2.x - this.p1.x;
        const dy = this.p2.y - this.p1.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > this.length * CONFIG.tearSensitivity) this.active = false;
        const diff = (this.length - dist) / dist * 0.5;
        const offsetX = dx * diff; const offsetY = dy * diff;
        if (!this.p1.pinned && this.p1 !== draggedPoint) { this.p1.x -= offsetX; this.p1.y -= offsetY; }
        if (!this.p2.pinned && this.p2 !== draggedPoint) { this.p2.x += offsetX; this.p2.y += offsetY; }
    }
    // Wireframe Draw
    draw(ctx) {
        if (!this.active || !this.isStructural) return;
        ctx.beginPath();
        ctx.moveTo(this.p1.x, this.p1.y);
        ctx.lineTo(this.p2.x, this.p2.y);
        
        if (this.health < 100) {
            const burnRatio = this.health / 100;
            ctx.strokeStyle = burnRatio > 0.5 ? `rgb(255, ${Math.floor(165*burnRatio)}, 0)` : '#333';
        } else {
            ctx.strokeStyle = currentMat.color;
        }
        ctx.stroke();
    }
}

// -----------------------------------------------------------
// SETUP
// -----------------------------------------------------------

let points = [];
let sticks = [];

function createCloth() {
    points = []; sticks = []; draggedPoint = null;
    const startX = (width - CONFIG.cols * CONFIG.spacing) / 2;
    const startY = 80;

    for (let y = 0; y < CONFIG.rows; y++) {
        for (let x = 0; x < CONFIG.cols; x++) {
            const pinned = y === 0;
            points.push(new Point(startX + x * CONFIG.spacing, startY + y * CONFIG.spacing, pinned));
        }
    }

    // Grid creation needed for mesh rendering later
    for (let y = 0; y < CONFIG.rows; y++) {
        for (let x = 0; x < CONFIG.cols; x++) {
            const i = y * CONFIG.cols + x;
            if (x < CONFIG.cols - 1) sticks.push(new Stick(points[i], points[i+1], true));
            if (y < CONFIG.rows - 1) sticks.push(new Stick(points[i], points[i+CONFIG.cols], true));
            if (x < CONFIG.cols - 1 && y < CONFIG.rows - 1) {
                sticks.push(new Stick(points[i], points[i+CONFIG.cols+1], false));
                sticks.push(new Stick(points[i+1], points[i+CONFIG.cols], false));
            }
        }
    }
}

// -----------------------------------------------------------
// VIEW & CONTROLS
// -----------------------------------------------------------

function setMaterial(name) {
    currentMat = MATERIALS[name];
    document.querySelectorAll('#controls button').forEach(b => b.classList.remove('active'));
    document.getElementById('btn-'+name).classList.add('active');
    // Restore UI states
    document.getElementById('tool-'+currentTool).classList.add('active');
    document.getElementById('view-'+viewMode).classList.add('active');
    updateWindButton();
}

function setTool(name) {
    currentTool = name;
    document.getElementById('tool-knife').classList.remove('active');
    document.getElementById('tool-lighter').classList.remove('active');
    document.getElementById('tool-'+name).classList.add('active');
    document.getElementById('tool-display').innerText = "Tool: " + (name === 'knife' ? "Knife" : "Lighter");
}

function setView(mode) {
    viewMode = mode;
    document.getElementById('view-wireframe').classList.remove('active');
    document.getElementById('view-textured').classList.remove('active');
    document.getElementById('view-'+mode).classList.add('active');
}

function toggleWind() {
    windEnabled = !windEnabled;
    updateWindButton();
}

function updateWindButton() {
    const btn = document.getElementById('btn-wind');
    btn.innerText = windEnabled ? "Wind: GALE FORCE" : "Wind: OFF";
    btn.style.background = windEnabled ? "#4fd1c5" : "#333";
    btn.style.color = windEnabled ? "#111" : "#fff";
}

// -----------------------------------------------------------
// RENDERING HELPERS
// -----------------------------------------------------------

function drawTextureMesh() {
    // 1. Define the Triangle Drawer Helper
    function drawTri(pA, pB, pC) {
        // Check lengths to prevent "giant shards" when cloth tears
        const d1 = Math.hypot(pB.x - pA.x, pB.y - pA.y);
        const d2 = Math.hypot(pC.x - pB.x, pC.y - pB.y);
        const d3 = Math.hypot(pA.x - pC.x, pA.y - pC.y);

        const limit = CONFIG.spacing * 2.2;
        if (d1 > limit || d2 > limit || d3 > limit) return; // Skip if torn

        ctx.beginPath();
        ctx.moveTo(pA.x, pA.y);
        ctx.lineTo(pB.x, pB.y);
        ctx.lineTo(pC.x, pC.y);
        
        // --- THIS IS THE COLOR FIX ---
        
        // Step A: Fill with the Texture Pattern
        ctx.fillStyle = clothPattern;
        ctx.fill();

        // Step B: Fill with Material Color (Semi-transparent)
        ctx.fillStyle = currentMat.color;
        ctx.globalAlpha = 0.5; // Adjust this (0.1 - 0.9) to change color intensity
        ctx.fill();
        
        ctx.globalAlpha = 1.0; // Reset opacity
        // -----------------------------
    }

    // 2. Loop through the grid
    for (let y = 0; y < CONFIG.rows - 1; y++) {
        for (let x = 0; x < CONFIG.cols - 1; x++) {
            const i = y * CONFIG.cols + x;
            const p1 = points[i];
            const p2 = points[i+1];
            const p3 = points[i + CONFIG.cols];
            const p4 = points[i + CONFIG.cols + 1];

            // Draw the quad as two triangles
            drawTri(p1, p2, p3);
            drawTri(p2, p4, p3);
        }
    }
}

// -----------------------------------------------------------
// MAIN LOOP
// -----------------------------------------------------------

function getIntersection(p1, p2, p3, p4) {
    const d = (p2.x - p1.x)*(p4.y - p3.y) - (p2.y - p1.y)*(p4.x - p3.x);
    if (d === 0) return false;
    const u = ((p3.x - p1.x)*(p4.y - p3.y) - (p3.y - p1.y)*(p4.x - p3.x)) / d;
    const v = ((p3.x - p1.x)*(p2.y - p1.y) - (p3.y - p1.y)*(p2.x - p1.x)) / d;
    return (u >= 0 && u <= 1 && v >= 0 && v <= 1);
}

function handleInput() {
    if (!mouse.down) { draggedPoint = null; return; }

    if (mouse.button === 0) { 
        if (currentTool === 'knife') {
            const cutStart = { x: mouse.px, y: mouse.py };
            const cutEnd = { x: mouse.x, y: mouse.y };
            if (cutStart.x === cutEnd.x && cutStart.y === cutEnd.y) return;
            for (let i = sticks.length - 1; i >= 0; i--) {
                if (!sticks[i].active) continue;
                if (getIntersection(cutStart, cutEnd, sticks[i].p1, sticks[i].p2)) {
                    sticks[i].active = false;
                }
            }
        } 
        else if (currentTool === 'lighter') {
            const burnRadius = 25;
            for (const s of sticks) {
                if (!s.active) continue;
                const midX = (s.p1.x + s.p2.x) / 2;
                const midY = (s.p1.y + s.p2.y) / 2;
                if (Math.hypot(midX - mouse.x, midY - mouse.y) < burnRadius) {
                    s.health -= 5 * currentMat.burnRate; 
                    if (s.health <= 0) s.active = false;
                }
            }
        }
    } 
}

function update() {
    ctx.clearRect(0, 0, width, height);

    // Physics
    for (const p of points) { p.update(); p.constrain(); }
    for (let i = 0; i < currentMat.stiffness; i++) {
        for (const s of sticks) s.update();
    }
    handleInput();

    // RENDER
    if (viewMode === 'textured') {
        // Draw Shadow first (simple blob)
        ctx.save();
        ctx.translate(15, 15);
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#000';
        drawTextureMesh(); // Draw shadow mesh
        ctx.restore();

        // Draw Actual Texture Mesh
        ctx.globalAlpha = 1.0;
        drawTextureMesh();
    } else {
        // Wireframe Mode (Classic) - Layered
        const LAYERS = [
            { x: 20, y: 20, color: '#4b0082', width: 3 }, 
            { x: 10, y: 10, color: '#0088aa', width: 2 }, 
            { x: 0,  y: 0,  color: null,      width: 1.5 } 
        ];
        for (let i = 0; i < LAYERS.length; i++) {
            const layer = LAYERS[i];
            ctx.save();
            ctx.translate(layer.x, layer.y);
            ctx.lineWidth = layer.width;
            for (const s of sticks) s.draw(ctx, layer.color); // layer.color null = heat/material
            ctx.restore();
        }
    }

    // UI Overlays
    if (currentTool === 'lighter') {
        ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 25, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255, 100, 0, 0.2)'; ctx.fill();
    }
    if(draggedPoint) {
        ctx.beginPath(); ctx.arc(draggedPoint.x, draggedPoint.y, 5, 0, Math.PI*2);
        ctx.fillStyle = '#fff'; ctx.fill();
    }

    mouse.px = mouse.x; mouse.py = mouse.y;
    requestAnimationFrame(update);
}

// Input Events
canvas.addEventListener('mousedown', e => {
    mouse.down = true; mouse.button = e.button;
    mouse.px = e.clientX; mouse.py = e.clientY;
    mouse.x = e.clientX; mouse.y = e.clientY;

    if (e.button === 2) { // Right click drag
        let nearest = null; let minDist = 40;
        for(const p of points) {
            const d = Math.hypot(p.x - mouse.x, p.y - mouse.y);
            if (d < minDist) { minDist = d; nearest = p; }
        }
        draggedPoint = nearest;
    }
});
canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
canvas.addEventListener('mouseup', () => { mouse.down = false; draggedPoint = null; });
canvas.addEventListener('contextmenu', e => e.preventDefault());

createCloth();
updateWindButton();
update();

</script>
</body>
</html>